<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Love Quest â€“ For Sara ğŸ’–</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(#fdd, #9cf);
    }
    canvas {
      display: block;
      margin: auto;
    }
      #restartBtn {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 10px 20px;
      font-size: 16px;
      background-color: #fff;
      border: 2px solid #d33;
      border-radius: 10px;
      cursor: pointer;
      z-index: 10;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <button id="restartBtn">Restart ğŸ”</button>
  <script>
    let updateId;
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
const backgroundImage = new Image();
backgroundImage.src = "https://i.ibb.co/5hvzJkyZ/images.jpg";

    const sara = {
  x: 50,
  y: 300,
  width: 30,
  height: 60,
  vy: 0,
  gravity: 0.6,
  jump: -12,
  grounded: true,
  ducking: false
};

    let score = 0;
    const messages = [
      "I love you so much, baby ğŸ’–",
      "You make me smile every day ğŸ’˜",
      "You are so stunning, my love ğŸ’‹",
      "Youâ€™re my whole world ğŸ’",
      "My forever valentine ğŸŒ¹",
      "You're sweeter than chocolate ğŸ«",
      "Youâ€™re my favorite hello ğŸ§¸",
    ];

    const items = ["ğŸ’Œ", "ğŸŒ¹", "ğŸ’‹", "ğŸ§¸", "ğŸ’", "ğŸ“", "ğŸ«"];

    let collectibles = [];
    let frameCount = 0;
let obstacles = [];
    let lastMessage = "";

    function spawnItem() {
      const emoji = items[Math.floor(Math.random() * items.length)];
      collectibles.push({
        x: canvas.width,
        y: 320,
        icon: emoji,
        collected: false,
      });
    }

    function drawSara() {
  ctx.fillStyle = "#000";
  ctx.save();
  const bounce = sara.vy < 0 ? -5 : 0;
  const slideOffset = sara.ducking && sara.grounded ? 5 : 0;
  ctx.translate(slideOffset, bounce);
  ctx.translate(0, bounce);

  const height = sara.ducking ? sara.height / 2 : sara.height;
  ctx.fillRect(sara.x, sara.y + (sara.height - height), sara.width, height);

  ctx.restore();
  ctx.beginPath();
  ctx.arc(sara.x + 15, sara.y - 10, 10, 0, Math.PI * 2);
  ctx.fill();
    }

    function drawCollectibles() {
      ctx.font = "32px Arial";
      collectibles.forEach((item) => {
        if (!item.collected) ctx.fillText(item.icon, item.x, item.y);
      });
    }

    function drawScore() {
      ctx.fillStyle = "#fff";
      ctx.font = "20px Arial";
      ctx.fillText("Score: " + score, 20, 30);
      if (lastMessage) ctx.fillText(lastMessage, 20, 60);
    }

    function spawnObstacle() {
  obstacles.push({ x: canvas.width, y: 330, width: 32, height: 32, icon: 'â„ï¸' });
}

function drawObstacles() {
  ctx.fillStyle = '#a00';
  obstacles.forEach((ob) => {
    ctx.font = '32px Arial';
    ctx.fillText(ob.icon || 'ğŸŸ¥', ob.x, ob.y);
  });
}

function checkObstacleCollision() {
  for (let i = 0; i < obstacles.length; i++) {
    const ob = obstacles[i];
    if (
      ob.x < sara.x + sara.width &&
      ob.x + ob.width > sara.x &&
      ob.y < sara.y + (sara.ducking ? sara.height / 2 : sara.height) &&
      ob.y + ob.height > sara.y
    ) {
      window.location.reload();
      return;
    }
  }
}

function update() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);

      // Gravity
      sara.vy += sara.gravity;
      sara.y += sara.vy;
      if (sara.y >= 300) {
        sara.y = 300;
        sara.vy = 0;
        sara.grounded = true;
      }

      // Update collectibles
      collectibles.forEach((item) => {
        item.x -= 4;
        if (!item.collected &&
            item.x < sara.x + sara.width &&
            item.x + 20 > sara.x &&
            item.y > sara.y && item.y < sara.y + sara.height) {
          item.collected = true;
          score++;
          lastMessage = messages[Math.floor(Math.random() * messages.length)];
        }
      });

      // Draw everything
      drawSara();
      drawCollectibles();
      drawScore();
  drawObstacles();
  

      // Clean up
      collectibles = collectibles.filter((item) => item.x > -40);

      // Spawn items every 90 frames
      if (frameCount % 90 === 0) spawnItem();

      obstacles.forEach(ob => ob.x -= 4);
  obstacles = obstacles.filter(ob => ob.x > -40);
  checkObstacleCollision();
  if (frameCount % 120 === 0) spawnObstacle();
  frameCount++;
      updateId = requestAnimationFrame(update);
    }

    document.addEventListener("keydown", (e) => {
  if ((e.key === " " || e.key === "ArrowUp") && sara.grounded) {
    sara.vy = sara.jump;
    sara.grounded = false;
  }
  if (e.key === "ArrowDown") {
    sara.ducking = true;
  }
});

document.addEventListener("keyup", (e) => {
  if (e.key === "ArrowDown") {
    sara.ducking = false;
  }
});

    document.getElementById("restartBtn").addEventListener("click", () => {
      collectibles = [];
      frameCount = 0;
      score = 0;
      lastMessage = "";
      sara.y = 300;
      sara.vy = 0;
      sara.grounded = true;
    });

    update();
  </script>
</body>
</html>
